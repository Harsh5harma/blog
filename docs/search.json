[
  {
    "objectID": "posts/stable-diffusion/index.html",
    "href": "posts/stable-diffusion/index.html",
    "title": "Stable Diffusion for dummies (written by a dummy)",
    "section": "",
    "text": "Most people reading this have probably heard of image generation at some point in time. If you’re among those who haven’t, then this journey will be even better as I go in some fair detail to try and explain what it is.\nIf at any point, the things I talk about seem hard, don’t be discouraged as it’s more of a shock if you find this easy to read. Nevertheless, buckle up because although we might not go all the way into the deep-end (I don’t know enough stuff yet), I think we’ll still get to dip our toes.\n\n\n\nI’ll just let the images speak.\n\n\n\n\n\n\n\n\ncozy warm image of an indian male programmer sitting near a beautiful pond, scenic, matches white background, beautiful\n\n\n\n\n\n\n\nDune arakis in the background. Paul Atreides giving speech. Crowd listening is charged, ominous foreboding theme.\n\n\n\n\n\n\n\n\n\ninspiring landscape poster showing humanity as a multiplanetary species, sprawling metropolis with large structures, awe-inspiring, 1920x1080 image, outer space\n\n\n\n\n\n\n\nAll of the above were generated with simple but detailed text prompts.\n\n\n\n\n\n\nCaution\n\n\n\nThis blog and deep learning in general have the tendency to contain lots of technical jargon. It might be something stupidly simple once you actually learn what it is, but for some reason the DL community likes cool names I guess. In case you’re a bit rusty with some of the terms, I’ve defined most used in this blog.\n\n\n\n\n\n\n\n\nJargon\n\n\n\n\n\n\n\n\n\n\n\n\nTerm\nMeaning\n\n\n\n\nparameters\nThe values in the model that change what task it can do, updated through model training\n\n\narchitecture\nThe mathematical function that we pass input data and parameters to\n\n\nmodel\nThe combination of the architecture with a particular set of parameters\n\n\ngradient\nA Tensor that tells us how the vector field changes in any direction\n\n\nloss\nA measure of how good the model is, chosen to drive training via stochastic gradient descent\n\n\nmetric\nA human readable way to measure the performance of a model\n\n\nCNN\nConvolutional Neural Network; a type of NN that works well for computer vision tasks\n\n\nembeddings\nA relatively-low dimension space into which we can translate high-dimensional vectors\n\n\nlatent\nA latent is a compressed, rough representation of a higher quality image. It consists of the most important features of an image\n\n\nlatent space\nA feature or embedding space where similar embeddings lie close to each other, and different farther.\n\n\nnoise\nRandom variation of brightness or color information in images\n\n\nU-Net\nDeep Learning architecture used for classifying each pixel in an image into a category or class\n\n\nVAE\nVariational Auto Encoder\n\n\nCLIP\nContrastive Language-Image Pre-Training, a visual classification NN\n\n\nmultimodal learning\nA type of learning where the model is trained to understand and work with multiple forms of input data\n\n\n\n\n\n\nIf you had to make a guess about how image generation works, what would that guess be? Think for a moment. If you’re like me, then you probably thought that we try to get the model to spit out cool looking images, right? Well, not exactly. Bear with me for a moment.  \nImagine a magic function that takes in images of handwritten digits as inputs and spits out the probability that the input is a digit.  \nLet the probability be \\(P(X)\\) for an input Image X.\n\n\n\n\nflowchart LR\n  I1(X1) --&gt; F((Magic Function))\n  I2(X2) --&gt; F\n  I3(X3) --&gt; F\n  F --&gt; O1(\"P(X1)\")\n  F --&gt; O2(\"P(X2)\")\n  F --&gt; O3(\"P(X3)\")\n\n\n\n\n\n\n\n\nWait. How do we use this function to generate new digits?\nWe do the following steps:\n\n\nTry making a pixel of X darker and then check the output probability\nTry making a pixel of X lighter and then check probability\nDo this for every pixel in X (If X is a 28x28 image, that’s 784 times!)\n\nIn the above steps, we’re calculating the change in probability of the images being handwritten wrt. to each pixel in the image (784 for a 28x28 image), mathematically it can be represented as follows: \\[\\nabla_X P(X)\\]\n\n\n\n\n\n\n\nNote\n\n\n\n\\(\\nabla_X P(X)\\) is itself a vector of size 784.\n\n\nNext step we do is to multiply \\(\\nabla_X P(X)\\) with some constant. \\[c*\\nabla_X P(X)\\]\nNow we subtract the above term from the 784 pixel values of \\(X\\) and in turn increase the output probability, and we do it a bunch of times.\n\n\n\n\n\nflowchart LR\n  I(X) --&gt; F((Magic Function))\n  F --&gt; O(\"P(X)\")\n  O --&gt; G[\"c * ∇ₓP(X)\"]\n  G --&gt; S[\"-\"]\n  S --&gt; I\n\n\n\n\n\n\n\nHaving gone through all that, it would be an intelligent guess to say that now all we need is for someone to give us the magic function so we can start generating.\n\nBut there’s some bad news, nobody is going to hand us any magical function that takes care of everything under the hood. We’re going to have to train our own neural network on a lot of handwritten data to do this for us.\n\nSeems simple enough to do for any seasoned DL practitioner. Alas! There’s a catch. Now I don’t know the why or how, but smarter people than me figured out that it’s pretty much practically impossible if not insanely hard to create a metric that tells us how much our image looks like a specific digit.\n\n\n\n\n\n\nImportant\n\n\n\nDon’t forget that our end goal is making super pretty images like we saw at the start, not some basic digits.\n\n\n\n\nSo, they decided on an interesting but very logical approach.\n\nEvery image we train on can be overlayed with some random amounts of noise, the result would be a noisier image of course but now we have some place to start with.\nNoisy Image = Noise + Clear Image\nWkt we can’t predict how much an image looks like something, but turns out we can try and predict how noisy an image is, and then using basic arithmetic we can see that we’d just have to subtract that predicted noise from the noisy image to end up with a relatively Clear Image.\n\nPassing in a starting pic and repeating this over and over would train our model to get good at predicting the noise in an image and getting rid of it.\n\nAnd once it has trained over enough inputs, it can generate new images for us because it now knows how to denoise inputs.\nSo we can use a model that works roughly in the fashion shown below:\n\n\n\n\nflowchart LR\n  I[\"Input Image\"] == \"(1)\" ==&gt; M((\"U-Net\"))\n  M == \"(2)\" ==&gt; O[\"Predicted Noise\"]\n  O == \"(3)\" ==&gt; Z[\"Subtracted from\"]\n  Z == \"(4)\" ==&gt; I\n  I == \"(5)\" ==&gt; nI[\"Less noisy image\"]\n  nI == \"(6)\" ==&gt; M\n\n\n\n\n\n\n\nAlthough the model above is decent, it can be optimised further using the concept of guidance. I’ll explain.\n\nCurrently, at the start of the training process, we’re leaving our model in the dark really with no clue about what digit it’s supposed to identify since we’re passing in somewhat noisy inputs.\n\nSay our model knew what it was supposed to look for, wouldn’t it make logical sense then to pass in that thing? That’s what guidance does. Along with the input (obviously), we also pass the digit our model is supposed to remove noise from.\n\nNow once the model is trained, guidance would help generate better new images, because it can denoise better! Duh. So our current model would actually end up looking more like:\n\n\n\n\nflowchart LR\n  I[\"Input Image\"] == \"(1)\" ==&gt; M((\"U-Net\"))\n  G[\"OHE Guidance Vector\"] == \"(1, 6)\" ==&gt; M\n  M == \"(2)\" ==&gt; O[\"Predicted Noise\"]\n  O == \"(3)\" ==&gt; Z[\"Subtracted from\"]\n  Z == \"(4)\" ==&gt; I\n  I == \"(5)\" ==&gt; nI[\"Less noisy image\"]\n  nI == \"(6)\" ==&gt; M\n\n\n\n\n\nNow if were living in the 90s, this model would certainly grab a lot of attention and maybe fame, but we’re not. We have overlooked some very grave issues.\n\nWe’re not working with tiny \\(28x28\\) pixel images of handwritten digits here, we’re working with \\(512x512x3\\) (High quality RGB) images.\nEach of our 9 handwritten digits can be one-hot encoded into a vector but beyond that, we can’t one-hot encode infinite possible texts.\n\n\n\n\n\n\n\nNote\n\n\n\nTry one hot encoding any phrase of your choice. It’s hard.\n\n\nWell then, is our case hopeless here? Were the images I showed faked? No, for we have the VAE autoencoder and the CLIP multimodal encoders and decoders to the rescue. Let’s understand what they are and get into how they solve both of our problems.\n\n\n\n\n\n\n\nVariational Auto Encoder\n\n\n\nIn the context of our model, VAE is just a data compression and decompression algorithm with a fancy name. \nVAE tries that what came in as input is the same as what comes out, it’s architecture might look similar to U-Net but VAE does not have cross connections unlike the former and VAE is also an autoencoder. \nThe special thing about autoencoders is that they can split in half and we can just use the encoder and decoder seperately.\nThe encoder serves as a great compression method and on the \\(512*512*3\\) example it reduces the pixel count from \\(786,432\\) to a mere \\(16,384\\). A size reduction of \\(48\\) times.\n\n\n\n\n\n\nImportant\n\n\n\nThe encoder peforms compression by doing stride 2 convolutions and doubling the channel size, this helps in increasing the complexity and expressive power of the model without increasing the spatial feature maps.\nSo, a stride 2 convolution reduces the spatial dimensions and memory usage and additional channels give the model more capacity to learn.\n\n\nAnd if we have a copy of the decoder, we can feed the encoded latent to it and end up with the high resolution image again.\nThis model serves a great compression algorithm because it’s been trained on millions upon millions of input images, at the start of its training process, the VAE spits out random noise out of it’s decoder but if we use the humble Mean Squared Error function on the encoder input and decoder output to train the VAE reduce the loss.\nHow it works is interesting though. VAE, is built up of two main components and each of them can work independently once the autoencoder has been trained.\n\nThe first part consists of the Encoder. This is where compression happens, we start with a high resolution image of \\(512*512*3\\) and keep performing convolutions of stride 2 and doubling the channels till we end up with a relatively much lower dimension image. This image is called the latent and the multi-dimensional space it exists in is called the latent space.\n\n\n\n\n\n\nNote\n\n\n\nA latent contains the most interesting and useful information of an image.\nA channel in a CNN refers to a specific component of the image data, in the case of a colour image, the channels typically represent different colors.\nA feature in CNN refers to specific characteristics or pattern in the input data that the network learns to recognise. These patterns can be simple or complex, early layers of a CNN features are basic patterns and deeper in the network, they’re more abstract and complex.\n\n\n\n\n\n\n\n\nNote\n\n\n\nA stride two convolution means that at each step, the convolution skips a column and a row. So for a \\(4*4\\) grid, a stride 2 convolution would bring the size down\n\n\n\n\n\n\nflowchart LR\n  A[\"High Res Image\"] --&gt; M((\"VAE Encoder\"))\n  M --&gt; O[\"Image Latent Tensor\"]\n\n\n\n\n\nNow let’s get back to what we need VAE for, the size problems our older model had. Since we can compress image sizes by godly amounts, there’s no doubt, that we’ll train the U-Net model with these encoded images (latents).\nSo, if our U-Net needs to be trained on 10 million images, we’ll pass each one of them through VAE's encoder first, and then we feed these latents into the U-Net 100s to 1000s of times.\n\n\n\n\n\n\nCaution\n\n\n\nDon’t forget that U-Net denoises input images through repetition.\n\n\nNow our model looks like this:\n\n\n\n\nflowchart LR\n  I[\"Noisy Latent Tensor\"] == \"(1)\" ==&gt; M((\"U-Net\"))\n  G[\"OHE Guidance Vector\"] == \"(1, 6)\" ==&gt; M\n  M == \"(2)\" ==&gt; O[\"Predicted Noise\"]\n  O == \"(3)\" ==&gt; Z[\"Subtracted From\"]\n  Z == \"(4)\" ==&gt; I\n  I == \"(5)\" ==&gt; nI[\"Less Noisy Latent Tensor\"]\n  nI == \"(6)\" ==&gt; M\n\n\n\n\n\nWouldn’t this new latent based model spit out latents too? Yes, it will but we don’t forget that we also have the other half of our autoencoder. The VAE decoder will be able to take in the generated latent as input and then output a high resolution image. It’d be like there wasn’t any compression-decompression to begin with.\n\n\n\n\nflowchart LR\n  A[\"U-Net Output Latent\"] --&gt; M((\"VAE Decoder\"))\n  M --&gt; O[\"High Res Version of Generated Image\"]\n\n\n\n\n\nTechnically we don’t need to use an autoencoder, but it greatly saves on computation necessary and the time it takes to generate an image as well as the modern training itself.\n\n\n\n\n\n\nNote\n\n\n\nVAE encoder: Used during model training.\nVAE decoder: Used during model inference.\n\n\n\n\n\nIgnore the weird name for now and focus on the second problem we had. Which was, finding a way to create embeddings for any possible text and not just the digits b/w 0 to 9 so we could guide the model.\nWhat if we had a model that spat out a vector representation of every complex sentence, such that we could pass it with our latent tensor as guidance. And what if, that model created textual embeddings in such a way, that they ended up being close to the latent tensor’s embedding in the latent space.\n\n\n\n\n\n\nMy personal intuition for this, could be wrong.\n\n\n\n\n\nIf the above paragraph was hard to get, I can explain with a more grounded example. I’m aware that the human brain and neural networks are not at all the same in the manner with which they function, and are designed but I couldn’t think of an easier example, so bear with me.\nImagine a guitar with a few broken strings, after reading this text could your brain think up of an image showing the same? It might not be super clear, 4k quality or something, but you could in your head think of an image that had the most important features that a guitar with a few broken strings might have.\nI think that a latent space is just that neural network analog for that headspace we go into. Our brain was able to process and break-down the text and then also match it to a visual representation.\nSo we essentially need a model, that is capable of doing something similar to this in essence. CLIP is one such model that does this job.\n\n\n\nCLIP is made up of two models. A Text-encoder and an Image-encoder.\n\n\n\n\nflowchart TD\n  T[\"Input text\"] --&gt; TE([\"CLIP Text Encoder\"])\n  I[\"Input Image\"] --&gt; IE([\"CLIP Image Encoder\"])\n  TE --&gt; VT[\"Vector Representation of Text\"]\n  IE --&gt; VI[\"Vector Representation of Image\"]\n  VT --&gt; LS((\"Latent Space\"))\n  VI --&gt; LS\n\n\n\n\n\nBoth encoders need to be trained first with randomly selected weights. The ‘CL’ in CLIP stands for contrastive loss and that’s what helps in training both the text and image encoders. Fancy name apart, training process is quite simple.\nLet’s take three random text prompts:\nText 1: Muscular Hen’s caricature\nText 2: Broken Egg\nText 3: Senior man with long hair and beard portrait\nWe’ll call the vector representation of each text prompt as T1, T2, T3 respectively.\nWe also now have 3 images of the same, and we’ll use I1, I2, I3 to represent the vector representations of these images. All of these vector representations were generated by throwing them into the CLIP encoders (and they’re random right now because we haven’t trained CLIP yet).\nNow, we can make a grid with the Image vectors lined up along the columns and the Text vectors lined along the rows.\n\n\n\nTraining Grid\n\n\nEach cell of the grid contains the dot product of the two representation vectors. The dot product of vectors that actually describe an image with the right text will be the highest, i.e. of the diagonal cells.\nThe non-diagonal cells on the other hand, should have low values once the model is trained, because the embeddings are far apart from each other in the latent-space. The text representation vector is not correct for the image.\nNow as the final step, we sum up all the diagonals together and we also sum up all the non-diagonals separately.\n\n\\(Sum_d = \\text{Sum of Diagonals}\\)\n\\(Sum_nd = \\text{Sum of Non-Diagonals}\\)\n\\(Loss = Sum_d - Sum_nd\\)\n\nThe loss function is known as Contrastive Loss, and it should be zero if all our generated embeddings are perfect matches.\nSo, to conclude this section. CLIP is a multi-modal model as our embeddings all share the same space and it helps us solve our second problem of not having a way to create embeddings for complex text.\n\n\n\n\n\n\n\nflowchart LR\n  I[\"Noisy Latent Tensor\"] == \"(1)\" ==&gt; M((\"U-Net\"))\n  G[\"CLIP Generated Embedding\"] == \"(1, 6)\" ==&gt; M\n  M == \"(2)\" ==&gt; O[\"Predicted Noise\"]\n  O == \"(3)\" ==&gt; Z[\"Subtracted From\"]\n  Z == \"(4)\" ==&gt; I\n  I == \"(5)\" ==&gt; nI[\"Less Noisy Latent Tensor\"]\n  nI == \"(6)\" ==&gt; M\n\n\n\n\n\nNow our model can take any image as input with any arbritarily complex text describing what the image is about and our model would be able to use that as guidance to denoise input latents better.\nAnd what about generation? For image generation, our model could take as input any random bits of noise and convert that noise into something that matches the text embedding by using the feature vectors of the very same embedding.\nThis model could serve as the final one, but in practice stable diffusion has one extra implementation detail that we haven’t discussed yet. It’s called Time-Steps.\n\n\n\nTo start off, time steps has nothing to do with time. It’s just an overhang from the math of the first few papers written on stable defusion.\nIt’s just a method of generating random noise for the inputs we pass in to our model. The noise used is varying and the noise schedule is some monotonically decreasing function.\n[width=70%]\nThe algorithm to pick noise is: 1. Randomly choose a number b/w 1-100 2. Look at noise schedule for that number.\nt=1 has a lot of noise, 1000 has the least. So the time-step t is pretty much telling us how much noise to use.\nHow is this used in practice? Well, we generate noise using the 2 steps above for each image in our mini-batch and we add that generated noise to each image in the mini-batch respectively.\n\n\n\n\n\n\nNote\n\n\n\nThese days, it’s widely accepted that the addition of noise to input images using time-steps in stable-diffusion impacted the quality of the generated images negatively and it’s not used in newer diffusion models."
  },
  {
    "objectID": "posts/stable-diffusion/index.html#cool-pics-to-pump-you-up",
    "href": "posts/stable-diffusion/index.html#cool-pics-to-pump-you-up",
    "title": "Stable Diffusion for dummies (written by a dummy)",
    "section": "",
    "text": "I’ll just let the images speak.\n\n\n\n\n\n\n\n\ncozy warm image of an indian male programmer sitting near a beautiful pond, scenic, matches white background, beautiful\n\n\n\n\n\n\n\nDune arakis in the background. Paul Atreides giving speech. Crowd listening is charged, ominous foreboding theme.\n\n\n\n\n\n\n\n\n\ninspiring landscape poster showing humanity as a multiplanetary species, sprawling metropolis with large structures, awe-inspiring, 1920x1080 image, outer space\n\n\n\n\n\n\n\nAll of the above were generated with simple but detailed text prompts.\n\n\n\n\n\n\nCaution\n\n\n\nThis blog and deep learning in general have the tendency to contain lots of technical jargon. It might be something stupidly simple once you actually learn what it is, but for some reason the DL community likes cool names I guess. In case you’re a bit rusty with some of the terms, I’ve defined most used in this blog.\n\n\n\n\n\n\n\n\nJargon\n\n\n\n\n\n\n\n\n\n\n\n\nTerm\nMeaning\n\n\n\n\nparameters\nThe values in the model that change what task it can do, updated through model training\n\n\narchitecture\nThe mathematical function that we pass input data and parameters to\n\n\nmodel\nThe combination of the architecture with a particular set of parameters\n\n\ngradient\nA Tensor that tells us how the vector field changes in any direction\n\n\nloss\nA measure of how good the model is, chosen to drive training via stochastic gradient descent\n\n\nmetric\nA human readable way to measure the performance of a model\n\n\nCNN\nConvolutional Neural Network; a type of NN that works well for computer vision tasks\n\n\nembeddings\nA relatively-low dimension space into which we can translate high-dimensional vectors\n\n\nlatent\nA latent is a compressed, rough representation of a higher quality image. It consists of the most important features of an image\n\n\nlatent space\nA feature or embedding space where similar embeddings lie close to each other, and different farther.\n\n\nnoise\nRandom variation of brightness or color information in images\n\n\nU-Net\nDeep Learning architecture used for classifying each pixel in an image into a category or class\n\n\nVAE\nVariational Auto Encoder\n\n\nCLIP\nContrastive Language-Image Pre-Training, a visual classification NN\n\n\nmultimodal learning\nA type of learning where the model is trained to understand and work with multiple forms of input data\n\n\n\n\n\n\nIf you had to make a guess about how image generation works, what would that guess be? Think for a moment. If you’re like me, then you probably thought that we try to get the model to spit out cool looking images, right? Well, not exactly. Bear with me for a moment.  \nImagine a magic function that takes in images of handwritten digits as inputs and spits out the probability that the input is a digit.  \nLet the probability be \\(P(X)\\) for an input Image X.\n\n\n\n\nflowchart LR\n  I1(X1) --&gt; F((Magic Function))\n  I2(X2) --&gt; F\n  I3(X3) --&gt; F\n  F --&gt; O1(\"P(X1)\")\n  F --&gt; O2(\"P(X2)\")\n  F --&gt; O3(\"P(X3)\")\n\n\n\n\n\n\n\n\nWait. How do we use this function to generate new digits?\nWe do the following steps:\n\n\nTry making a pixel of X darker and then check the output probability\nTry making a pixel of X lighter and then check probability\nDo this for every pixel in X (If X is a 28x28 image, that’s 784 times!)\n\nIn the above steps, we’re calculating the change in probability of the images being handwritten wrt. to each pixel in the image (784 for a 28x28 image), mathematically it can be represented as follows: \\[\\nabla_X P(X)\\]\n\n\n\n\n\n\n\nNote\n\n\n\n\\(\\nabla_X P(X)\\) is itself a vector of size 784.\n\n\nNext step we do is to multiply \\(\\nabla_X P(X)\\) with some constant. \\[c*\\nabla_X P(X)\\]\nNow we subtract the above term from the 784 pixel values of \\(X\\) and in turn increase the output probability, and we do it a bunch of times.\n\n\n\n\n\nflowchart LR\n  I(X) --&gt; F((Magic Function))\n  F --&gt; O(\"P(X)\")\n  O --&gt; G[\"c * ∇ₓP(X)\"]\n  G --&gt; S[\"-\"]\n  S --&gt; I\n\n\n\n\n\n\n\nHaving gone through all that, it would be an intelligent guess to say that now all we need is for someone to give us the magic function so we can start generating.\n\nBut there’s some bad news, nobody is going to hand us any magical function that takes care of everything under the hood. We’re going to have to train our own neural network on a lot of handwritten data to do this for us.\n\nSeems simple enough to do for any seasoned DL practitioner. Alas! There’s a catch. Now I don’t know the why or how, but smarter people than me figured out that it’s pretty much practically impossible if not insanely hard to create a metric that tells us how much our image looks like a specific digit.\n\n\n\n\n\n\nImportant\n\n\n\nDon’t forget that our end goal is making super pretty images like we saw at the start, not some basic digits.\n\n\n\n\nSo, they decided on an interesting but very logical approach.\n\nEvery image we train on can be overlayed with some random amounts of noise, the result would be a noisier image of course but now we have some place to start with.\nNoisy Image = Noise + Clear Image\nWkt we can’t predict how much an image looks like something, but turns out we can try and predict how noisy an image is, and then using basic arithmetic we can see that we’d just have to subtract that predicted noise from the noisy image to end up with a relatively Clear Image.\n\nPassing in a starting pic and repeating this over and over would train our model to get good at predicting the noise in an image and getting rid of it.\n\nAnd once it has trained over enough inputs, it can generate new images for us because it now knows how to denoise inputs.\nSo we can use a model that works roughly in the fashion shown below:\n\n\n\n\nflowchart LR\n  I[\"Input Image\"] == \"(1)\" ==&gt; M((\"U-Net\"))\n  M == \"(2)\" ==&gt; O[\"Predicted Noise\"]\n  O == \"(3)\" ==&gt; Z[\"Subtracted from\"]\n  Z == \"(4)\" ==&gt; I\n  I == \"(5)\" ==&gt; nI[\"Less noisy image\"]\n  nI == \"(6)\" ==&gt; M\n\n\n\n\n\n\n\nAlthough the model above is decent, it can be optimised further using the concept of guidance. I’ll explain.\n\nCurrently, at the start of the training process, we’re leaving our model in the dark really with no clue about what digit it’s supposed to identify since we’re passing in somewhat noisy inputs.\n\nSay our model knew what it was supposed to look for, wouldn’t it make logical sense then to pass in that thing? That’s what guidance does. Along with the input (obviously), we also pass the digit our model is supposed to remove noise from.\n\nNow once the model is trained, guidance would help generate better new images, because it can denoise better! Duh. So our current model would actually end up looking more like:\n\n\n\n\nflowchart LR\n  I[\"Input Image\"] == \"(1)\" ==&gt; M((\"U-Net\"))\n  G[\"OHE Guidance Vector\"] == \"(1, 6)\" ==&gt; M\n  M == \"(2)\" ==&gt; O[\"Predicted Noise\"]\n  O == \"(3)\" ==&gt; Z[\"Subtracted from\"]\n  Z == \"(4)\" ==&gt; I\n  I == \"(5)\" ==&gt; nI[\"Less noisy image\"]\n  nI == \"(6)\" ==&gt; M\n\n\n\n\n\nNow if were living in the 90s, this model would certainly grab a lot of attention and maybe fame, but we’re not. We have overlooked some very grave issues.\n\nWe’re not working with tiny \\(28x28\\) pixel images of handwritten digits here, we’re working with \\(512x512x3\\) (High quality RGB) images.\nEach of our 9 handwritten digits can be one-hot encoded into a vector but beyond that, we can’t one-hot encode infinite possible texts.\n\n\n\n\n\n\n\nNote\n\n\n\nTry one hot encoding any phrase of your choice. It’s hard.\n\n\nWell then, is our case hopeless here? Were the images I showed faked? No, for we have the VAE autoencoder and the CLIP multimodal encoders and decoders to the rescue. Let’s understand what they are and get into how they solve both of our problems."
  },
  {
    "objectID": "posts/stable-diffusion/index.html#vae-variational-auto-encoder",
    "href": "posts/stable-diffusion/index.html#vae-variational-auto-encoder",
    "title": "Stable Diffusion for dummies (written by a dummy)",
    "section": "",
    "text": "Variational Auto Encoder\n\n\n\nIn the context of our model, VAE is just a data compression and decompression algorithm with a fancy name. \nVAE tries that what came in as input is the same as what comes out, it’s architecture might look similar to U-Net but VAE does not have cross connections unlike the former and VAE is also an autoencoder. \nThe special thing about autoencoders is that they can split in half and we can just use the encoder and decoder seperately.\nThe encoder serves as a great compression method and on the \\(512*512*3\\) example it reduces the pixel count from \\(786,432\\) to a mere \\(16,384\\). A size reduction of \\(48\\) times.\n\n\n\n\n\n\nImportant\n\n\n\nThe encoder peforms compression by doing stride 2 convolutions and doubling the channel size, this helps in increasing the complexity and expressive power of the model without increasing the spatial feature maps.\nSo, a stride 2 convolution reduces the spatial dimensions and memory usage and additional channels give the model more capacity to learn.\n\n\nAnd if we have a copy of the decoder, we can feed the encoded latent to it and end up with the high resolution image again.\nThis model serves a great compression algorithm because it’s been trained on millions upon millions of input images, at the start of its training process, the VAE spits out random noise out of it’s decoder but if we use the humble Mean Squared Error function on the encoder input and decoder output to train the VAE reduce the loss.\nHow it works is interesting though. VAE, is built up of two main components and each of them can work independently once the autoencoder has been trained.\n\nThe first part consists of the Encoder. This is where compression happens, we start with a high resolution image of \\(512*512*3\\) and keep performing convolutions of stride 2 and doubling the channels till we end up with a relatively much lower dimension image. This image is called the latent and the multi-dimensional space it exists in is called the latent space.\n\n\n\n\n\n\nNote\n\n\n\nA latent contains the most interesting and useful information of an image.\nA channel in a CNN refers to a specific component of the image data, in the case of a colour image, the channels typically represent different colors.\nA feature in CNN refers to specific characteristics or pattern in the input data that the network learns to recognise. These patterns can be simple or complex, early layers of a CNN features are basic patterns and deeper in the network, they’re more abstract and complex.\n\n\n\n\n\n\n\n\nNote\n\n\n\nA stride two convolution means that at each step, the convolution skips a column and a row. So for a \\(4*4\\) grid, a stride 2 convolution would bring the size down\n\n\n\n\n\n\nflowchart LR\n  A[\"High Res Image\"] --&gt; M((\"VAE Encoder\"))\n  M --&gt; O[\"Image Latent Tensor\"]\n\n\n\n\n\nNow let’s get back to what we need VAE for, the size problems our older model had. Since we can compress image sizes by godly amounts, there’s no doubt, that we’ll train the U-Net model with these encoded images (latents).\nSo, if our U-Net needs to be trained on 10 million images, we’ll pass each one of them through VAE's encoder first, and then we feed these latents into the U-Net 100s to 1000s of times.\n\n\n\n\n\n\nCaution\n\n\n\nDon’t forget that U-Net denoises input images through repetition.\n\n\nNow our model looks like this:\n\n\n\n\nflowchart LR\n  I[\"Noisy Latent Tensor\"] == \"(1)\" ==&gt; M((\"U-Net\"))\n  G[\"OHE Guidance Vector\"] == \"(1, 6)\" ==&gt; M\n  M == \"(2)\" ==&gt; O[\"Predicted Noise\"]\n  O == \"(3)\" ==&gt; Z[\"Subtracted From\"]\n  Z == \"(4)\" ==&gt; I\n  I == \"(5)\" ==&gt; nI[\"Less Noisy Latent Tensor\"]\n  nI == \"(6)\" ==&gt; M\n\n\n\n\n\nWouldn’t this new latent based model spit out latents too? Yes, it will but we don’t forget that we also have the other half of our autoencoder. The VAE decoder will be able to take in the generated latent as input and then output a high resolution image. It’d be like there wasn’t any compression-decompression to begin with.\n\n\n\n\nflowchart LR\n  A[\"U-Net Output Latent\"] --&gt; M((\"VAE Decoder\"))\n  M --&gt; O[\"High Res Version of Generated Image\"]\n\n\n\n\n\nTechnically we don’t need to use an autoencoder, but it greatly saves on computation necessary and the time it takes to generate an image as well as the modern training itself.\n\n\n\n\n\n\nNote\n\n\n\nVAE encoder: Used during model training.\nVAE decoder: Used during model inference."
  },
  {
    "objectID": "posts/stable-diffusion/index.html#clip",
    "href": "posts/stable-diffusion/index.html#clip",
    "title": "Stable Diffusion for dummies (written by a dummy)",
    "section": "",
    "text": "Ignore the weird name for now and focus on the second problem we had. Which was, finding a way to create embeddings for any possible text and not just the digits b/w 0 to 9 so we could guide the model.\nWhat if we had a model that spat out a vector representation of every complex sentence, such that we could pass it with our latent tensor as guidance. And what if, that model created textual embeddings in such a way, that they ended up being close to the latent tensor’s embedding in the latent space.\n\n\n\n\n\n\nMy personal intuition for this, could be wrong.\n\n\n\n\n\nIf the above paragraph was hard to get, I can explain with a more grounded example. I’m aware that the human brain and neural networks are not at all the same in the manner with which they function, and are designed but I couldn’t think of an easier example, so bear with me.\nImagine a guitar with a few broken strings, after reading this text could your brain think up of an image showing the same? It might not be super clear, 4k quality or something, but you could in your head think of an image that had the most important features that a guitar with a few broken strings might have.\nI think that a latent space is just that neural network analog for that headspace we go into. Our brain was able to process and break-down the text and then also match it to a visual representation.\nSo we essentially need a model, that is capable of doing something similar to this in essence. CLIP is one such model that does this job.\n\n\n\nCLIP is made up of two models. A Text-encoder and an Image-encoder.\n\n\n\n\nflowchart TD\n  T[\"Input text\"] --&gt; TE([\"CLIP Text Encoder\"])\n  I[\"Input Image\"] --&gt; IE([\"CLIP Image Encoder\"])\n  TE --&gt; VT[\"Vector Representation of Text\"]\n  IE --&gt; VI[\"Vector Representation of Image\"]\n  VT --&gt; LS((\"Latent Space\"))\n  VI --&gt; LS\n\n\n\n\n\nBoth encoders need to be trained first with randomly selected weights. The ‘CL’ in CLIP stands for contrastive loss and that’s what helps in training both the text and image encoders. Fancy name apart, training process is quite simple.\nLet’s take three random text prompts:\nText 1: Muscular Hen’s caricature\nText 2: Broken Egg\nText 3: Senior man with long hair and beard portrait\nWe’ll call the vector representation of each text prompt as T1, T2, T3 respectively.\nWe also now have 3 images of the same, and we’ll use I1, I2, I3 to represent the vector representations of these images. All of these vector representations were generated by throwing them into the CLIP encoders (and they’re random right now because we haven’t trained CLIP yet).\nNow, we can make a grid with the Image vectors lined up along the columns and the Text vectors lined along the rows.\n\n\n\nTraining Grid\n\n\nEach cell of the grid contains the dot product of the two representation vectors. The dot product of vectors that actually describe an image with the right text will be the highest, i.e. of the diagonal cells.\nThe non-diagonal cells on the other hand, should have low values once the model is trained, because the embeddings are far apart from each other in the latent-space. The text representation vector is not correct for the image.\nNow as the final step, we sum up all the diagonals together and we also sum up all the non-diagonals separately.\n\n\\(Sum_d = \\text{Sum of Diagonals}\\)\n\\(Sum_nd = \\text{Sum of Non-Diagonals}\\)\n\\(Loss = Sum_d - Sum_nd\\)\n\nThe loss function is known as Contrastive Loss, and it should be zero if all our generated embeddings are perfect matches.\nSo, to conclude this section. CLIP is a multi-modal model as our embeddings all share the same space and it helps us solve our second problem of not having a way to create embeddings for complex text."
  },
  {
    "objectID": "posts/stable-diffusion/index.html#updated-model",
    "href": "posts/stable-diffusion/index.html#updated-model",
    "title": "Stable Diffusion for dummies (written by a dummy)",
    "section": "",
    "text": "flowchart LR\n  I[\"Noisy Latent Tensor\"] == \"(1)\" ==&gt; M((\"U-Net\"))\n  G[\"CLIP Generated Embedding\"] == \"(1, 6)\" ==&gt; M\n  M == \"(2)\" ==&gt; O[\"Predicted Noise\"]\n  O == \"(3)\" ==&gt; Z[\"Subtracted From\"]\n  Z == \"(4)\" ==&gt; I\n  I == \"(5)\" ==&gt; nI[\"Less Noisy Latent Tensor\"]\n  nI == \"(6)\" ==&gt; M\n\n\n\n\n\nNow our model can take any image as input with any arbritarily complex text describing what the image is about and our model would be able to use that as guidance to denoise input latents better.\nAnd what about generation? For image generation, our model could take as input any random bits of noise and convert that noise into something that matches the text embedding by using the feature vectors of the very same embedding.\nThis model could serve as the final one, but in practice stable diffusion has one extra implementation detail that we haven’t discussed yet. It’s called Time-Steps."
  },
  {
    "objectID": "posts/stable-diffusion/index.html#time-steps",
    "href": "posts/stable-diffusion/index.html#time-steps",
    "title": "Stable Diffusion for dummies (written by a dummy)",
    "section": "",
    "text": "To start off, time steps has nothing to do with time. It’s just an overhang from the math of the first few papers written on stable defusion.\nIt’s just a method of generating random noise for the inputs we pass in to our model. The noise used is varying and the noise schedule is some monotonically decreasing function.\n[width=70%]\nThe algorithm to pick noise is: 1. Randomly choose a number b/w 1-100 2. Look at noise schedule for that number.\nt=1 has a lot of noise, 1000 has the least. So the time-step t is pretty much telling us how much noise to use.\nHow is this used in practice? Well, we generate noise using the 2 steps above for each image in our mini-batch and we add that generated noise to each image in the mini-batch respectively.\n\n\n\n\n\n\nNote\n\n\n\nThese days, it’s widely accepted that the addition of noise to input images using time-steps in stable-diffusion impacted the quality of the generated images negatively and it’s not used in newer diffusion models."
  },
  {
    "objectID": "calculation.html",
    "href": "calculation.html",
    "title": "Theory Threads and Dev Doodles",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Generate random data for time steps and corresponding noise levels\ntime_steps = np.arange(0, 1000, 1)  # Assuming 100 time steps\nnoise_levels =[-(x)**2 + 30*x + 2 for x in range(1,1001)] # Random noise levels between 0 and 1\n\n# Plotting the time-step noise schedule graph\nplt.figure(figsize=(10, 6))\nplt.plot(time_steps, noise_levels, color='b', label='Noise Schedule')\nplt.xlabel('Time Steps')\nplt.ylabel('Noise Schedule')\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hey! I’m Harsh Sharma, a 20 yr old CS student with a new found interest for Deep learning. I love writing code and learning concepts that make me tear my hair out ; )\nI was introduced to the basics of HTML, CSS and some python in middle school and early high school, but I started programming much more seriously a few months before starting college.\nI also share a deep love for core CS concepts and the most recent project I did was related to writing my own little toy language. The languages I’m comfortable with include Python, C++, C, Javascript (and maybe Java). Other than that I’m also quite familar with HTML&CSS and am currently learning React as well.\nTech stuff apart, I love reading and listening to music. Current book of mine is The Republic by Plato and my favorite band atm is Nine Inch Nails (Ghosts I-IV 🤘)."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Theory Threads and Dev Doodles",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nStable Diffusion for dummies (written by a dummy)\n\n\n\n\n\n\n\nNotes\n\n\nFastai Part2\n\n\n\n\nA little informal guide for diffusion first timers.\n\n\n\n\n\n\nOct 29, 2023\n\n\nHarsh Sharma\n\n\n\n\n\n\nNo matching items"
  }
]