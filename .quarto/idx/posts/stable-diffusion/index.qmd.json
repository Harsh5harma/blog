{"title":"Noisy to Nice","markdown":{"yaml":{"title":"Noisy to Nice","description":"An amateur's guide to stable diffusion.","author":"Harsh Sharma","date":"10/31/2023","image":"logo.png","toc":true,"toc-expand":2,"toc-title":"Contents","toc-location":"left","number-sections":true,"number-depth":3,"categories":["Notes","Fastai Part2"]},"headingText":"Introduction","containsRefs":false,"markdown":"\n:::{.callout-caution title=\"About this blog\" collapse=\"true\"}\nThis is my first ever blog and it's on a topic I find relatively hard, although I've tried my best to be accurate in whatever I write, It won't be surprising if this entire blog was riddled with inaccuracies and straight up incorrect stuff. I simply don't have that necessary but aquired oversight yet. So I'm asking the reader to help me out with any errors they might spot and I'll happily correct whatever it is that I presented wrong.\n:::\nMost people reading this have probably heard of image generation at some point in time. If you're among those who haven't, then this journey will be even better as I go in some fair detail to try and explain what it is.\n\nIf at any point, the things I talk about seem hard, don't be discouraged as it's more of a shock if you find this easy to read. Nevertheless, buckle up because although we might not go all the way into the deep-end (I don't know enough stuff yet), I think we'll still get to dip our toes.\n\n![](buckleup.gif){width=40%}\n\\ \n\n# Cool AI generated images\nI'll just let the images speak.  \n\\\n\n::: {layout=\"[[1,1], [1]]\"}\n![cozy warm image of an indian male programmer sitting near a beautiful pond, scenic, matches white background, beautiful](img3.jpg){width=50%}\n\n![Dune arakis in the background. Paul Atreides giving speech. Crowd listening is charged, ominous foreboding theme.](img4.jpg){width=50%}\n\n![inspiring landscape poster showing humanity as a multiplanetary species, sprawling metropolis with large structures, awe-inspiring, 1920x1080 image, outer space](img5.jpg)\n:::\n\\\n\nAll of the above were generated with simple but detailed text prompts.\n\\ \n# Understanding the problem\n\n::: {.callout-caution}\nThis blog and deep learning in general have the tendency to contain lots of technical jargon. It might be something stupidly simple once you actually learn what it is, but for some reason the DL community likes cool names I guess. In case you're a bit rusty with some of the terms, I've defined most used in this blog.\n:::\n::: {.callout-note collapse='true' title='Jargon' }\n|Term | Meaning |\n|-----|------------|\n|parameters| The values in the model that change what task it can do, updated through model training|\n| architecture | The mathematical function that we pass input data and parameters to |\n|model | The combination of the architecture with a particular set of parameters|  \n|gradient | A Tensor that tells us how the vector field changes in any direction |\n| loss | A measure of how good the model is, chosen to drive training via stochastic gradient descent|\n|metric| A human readable way to measure the performance of a model |\n|CNN| Convolutional Neural Network; a type of NN that works well for computer vision tasks | \n| embeddings | A relatively-low dimension space into which we can translate high-dimensional vectors|\n| latent | A latent is a compressed, rough representation of a higher quality image. It consists of the most important features of an image|\n|latent space| A feature or embedding space where similar embeddings lie close to each other, and different farther.|\n|noise| Random variation of brightness or color information in images|\n|U-Net| Deep Learning architecture used for classifying each pixel in an image into a category or class|\n|VAE| Variational Auto Encoder|\n|CLIP| Contrastive Language-Image Pre-Training, a visual classification NN|\n|multimodal learning| A type of learning where the model is trained to understand and work with multiple forms of input data |\n:::\n\nIf you had to make a guess about how image generation works, what would that guess be? Think for a moment. If you're like me, then you probably thought that we try to get the model to spit out cool looking images, right? Well, not exactly. Bear with me for a moment.\n\\ \n\nImagine a magic function that takes in images of handwritten digits as inputs and spits out the probability that the input is a digit. \n\\ \n\nLet the probability be $P(X)$ for an input Image X.\n```{mermaid}\nflowchart LR\n  I1(X1) --> F((Magic Function))\n  I2(X2) --> F\n  I3(X3) --> F\n  F --> O1(\"P(X1)\")\n  F --> O2(\"P(X2)\")\n  F --> O3(\"P(X3)\")\n\n```\n\n\\\n\nWait. How do we use this function to generate new digits?\\\nWe do the following steps:\\\n\n1. Try making a pixel of X darker and then check the output probability\n2. Try making a pixel of X lighter and then check probability\n3. Do this for every pixel in X (If X is a 28x28 image, that's 784 times!)\n\nIn the above steps, we're calculating the change in probability of the images being handwritten wrt. to each pixel in the image (784 for a 28x28 image), mathematically it can be represented as follows: \n$$\\nabla_X P(X)$$\n\\\n\n::: {.callout-note}\n$\\nabla_X P(X)$ is itself a vector of size 784.\n:::\n\nNext step we do is to multiply $\\nabla_X P(X)$ with some constant.\n$$c*\\nabla_X P(X)$$\n\nNow we subtract the above term from the 784 pixel values of $X$ and in turn increase the output probability, and we do it a bunch of times.\\\n\n```{mermaid}\nflowchart LR\n  I(X) --> F((Magic Function))\n  F --> O(\"P(X)\")\n  O --> G[\"c * ∇ₓP(X)\"]\n  G --> S[\"-\"]\n  S --> I\n```\n\\\n\nHaving gone through all that, it would be an intelligent guess to say that now all we need is for someone to give us the magic function so we can start generating.\\\n\nBut there's some bad news, nobody is going to hand us any magical function that takes care of everything under the hood. We're going to have to train our own neural network on a lot of handwritten data to do this for us.\\\n\nSeems simple enough to do for any seasoned DL practitioner. Alas! There's a catch. Now I don't know the why or how, but smarter people than me figured out that it's pretty much practically impossible if not insanely hard to create a metric that tells us how much our image looks like a specific digit. \n\n:::{.callout-important}\nDon't forget that our end goal is making super pretty images like we saw at the start, not some basic digits.\n:::\nSo, they decided on an interesting but very logical approach.\\\n\n# An attempt at a basic image generation model\n\nEvery image we train on can be overlayed with some random amounts of noise, the result would be a noisier image of course but now we have some place to start with.\\\n`Noisy Image = Noise + Clear Image`\n\nWkt we can't predict how much an image looks like something, but turns out we can try and predict how noisy an image is, and then using basic arithmetic we can see that we'd just have to subtract that predicted noise from the noisy image to end up with a relatively clear Image. \\\n\nPassing in a starting pic and repeating this over and over would train our model to get good at predicting the noise in an image and getting rid of it. \\\n\nAnd once it has trained over enough inputs, it can generate new images for us because it now knows how to denoise inputs.\n\nSo we can use a model that works roughly in the fashion shown below:\n\n```{mermaid}\nflowchart LR\n  I[\"Input Image\"] == \"(1)\" ==> M((\"U-Net\"))\n  M == \"(2)\" ==> O[\"Predicted Noise\"]\n  O == \"(3)\" ==> Z[\"Subtracted from\"]\n  Z == \"(4)\" ==> I\n  I == \"(5)\" ==> nI[\"Less noisy image\"]\n  nI == \"(6)\" ==> M\n```\n\n\\\n\nAlthough the model above is decent, it can be optimised further using the concept of *guidance*. I'll explain.\\\n\nCurrently, at the start of the training process, we're leaving our model in the dark really with no clue about what digit it's supposed to identify since we're passing in somewhat noisy inputs.\\\n\nSay our model knew what it was supposed to look for, wouldn't it make logical sense then to pass in that thing? That's what guidance does. Along with the input (obviously), we also pass the digit our model is supposed to remove noise from.\\\n\nNow once the model is trained, *guidance* would help generate better new images, because it can denoise better! Duh. So our current model would actually end up looking more like: \n\n```{mermaid}\nflowchart LR\n  I[\"Input Image\"] == \"(1)\" ==> M((\"U-Net\"))\n  G[\"OHE Guidance Vector\"] == \"(1, 6)\" ==> M\n  M == \"(2)\" ==> O[\"Predicted Noise\"]\n  O == \"(3)\" ==> Z[\"Subtracted from\"]\n  Z == \"(4)\" ==> I\n  I == \"(5)\" ==> nI[\"Less noisy image\"]\n  nI == \"(6)\" ==> M\n```\n\n\n# Problems with our basic model\n\nIf we were living in the 90s, the model we built would certainly grab a lot of attention and maybe fame, but we're not. We have overlooked some very grave issues.\n\n1. We're not working with tiny $28x28$ pixel images of handwritten digits here, we're working with $512x512x3$ (High quality RGB) images.\n2. Each of our 9 handwritten digits can be one-hot encoded into a vector but beyond that, we can't one-hot encode infinite possible texts. \n\n:::{.callout-note }\nTry one hot encoding any phrase of your choice. It's hard.\n:::\n\nWell then, is our case hopeless here? Were the images I showed faked? No, for we have the `VAE autoencoder` and the `CLIP` multimodal encoders and decoders to the rescue. Let's understand what they are and get into how they solve both of our problems.\n\\\n\n## VAE: Variational Auto Encoder\n\n![Variational Auto Encoder](VAE.png)\n\n\\\nIn the context of our model, VAE is just a data compression and decompression algorithm with a fancy name.\\ \n\nVAE tries that what came in as input is the same as what comes out, it's architecture might look similar to U-Net but VAE does not have cross connections unlike the former and VAE is also an autoencoder.\\ \n\nThe special thing about autoencoders is that they can split in half and we can just use the encoder and decoder seperately.\n\nThe encoder serves as a great compression method and on the $512*512*3$ example it reduces the pixel count from $786,432$ to a mere $16,384$. A size reduction of $48$ times. \n\n:::{.callout-important}\nThe encoder peforms compression by doing stride 2 convolutions and doubling the channel size, this helps in increasing the complexity and expressive power of the model without increasing the spatial feature maps.\n\nSo, a stride 2 convolution reduces the spatial dimensions and memory usage and additional channels give the model more capacity to learn.\n:::\n\nAnd if we have a copy of the decoder, we can feed the encoded latent to it and end up with the high resolution image again. \n\nThis model serves a great compression algorithm because it's been trained on millions upon millions of input images, at the start of its training process, the VAE spits out random noise out of it's decoder but if we use the humble `Mean Squared Error` function on the encoder input and decoder output to train the VAE reduce the loss.\n\n\nHow it works is interesting though. VAE, is built up of two main components and each of them can work independently once the autoencoder has been trained.\\\n\nThe first part consists of the Encoder. This is where compression happens, we start with a high resolution image of $512*512*3$ and keep performing convolutions of stride 2 and doubling the channels till we end up with a relatively much lower dimension image. This image is called the `latent` and the multi-dimensional space it exists in is called the `latent space`.\n\n:::{.callout-note}\nA `latent` contains the most interesting and useful information of an image.\n\nA `channel` in a CNN refers to a specific component of the image data, in the case of a colour image, the channels typically represent different colors.\n\nA `feature` in CNN refers to specific characteristics or pattern in the input data that the network learns to recognise. These patterns can be simple or complex, early layers of a CNN features are basic patterns and deeper in the network, they're more abstract and complex.\n:::\n\n:::{.callout-note}\nA stride two convolution means that at each step, the convolution skips a column and a row. So for a $4*4$ grid, a stride 2 convolution would bring the size down\n:::\n\n```{mermaid}\nflowchart LR\n  A[\"High Res Image\"] --> M((\"VAE Encoder\"))\n  M --> O[\"Image Latent Tensor\"]\n```\n\nNow let's get back to what we need VAE for, the size problems our older model had. Since we can compress image sizes by godly amounts, there's no doubt, that we'll train the U-Net model with these encoded images (latents).\n\nSo, if our U-Net needs to be trained on 10 million images, we'll pass each one of them through `VAE's encoder` first, and then we feed these latents into the U-Net 100s to 1000s of times.\n\n:::{.callout-caution}\nDon't forget that U-Net denoises input images through repetition.\n:::\n\nNow our model looks like this:\n```{mermaid}\nflowchart LR\n  I[\"Noisy Latent Tensor\"] == \"(1)\" ==> M((\"U-Net\"))\n  G[\"OHE Guidance Vector\"] == \"(1, 6)\" ==> M\n  M == \"(2)\" ==> O[\"Predicted Noise\"]\n  O == \"(3)\" ==> Z[\"Subtracted From\"]\n  Z == \"(4)\" ==> I\n  I == \"(5)\" ==> nI[\"Less Noisy Latent Tensor\"]\n  nI == \"(6)\" ==> M\n```\n\nWouldn't this new latent based model spit out latents too? Yes, it will but we don't forget that we also have the other half of our autoencoder. The `VAE decoder` will be able to take in the generated latent as input and then output a high resolution image. It'd be like there wasn't any compression-decompression to begin with. \n\n```{mermaid}\nflowchart LR\n  A[\"U-Net Output Latent\"] --> M((\"VAE Decoder\"))\n  M --> O[\"High Res Version of Generated Image\"]\n```\n\nTechnically we don't need to use an autoencoder, but it greatly saves on computation necessary and the time it takes to generate an image as well as the modern training itself.\n\n:::{.callout-note}\n`VAE encoder`: Used during model training.\n\n`VAE decoder`: Used during model inference.\n:::\n\n## CLIP\n\nIgnore the weird name for now and focus on the second problem we had. \nWhich was, finding a way to create embeddings for any possible text and not just the digits b/w 0 to 9 so we could guide the model.\n\nWhat if we had a model that spat out a vector representation of every complex sentence, such that we could pass it with our `latent tensor` as `guidance`. And what if, that model created textual embeddings in such a way, that they ended up being close to the `latent tensor`'s embedding in the `latent space`.\n\n:::{.callout-warning collapse=\"true\" title=\"My personal intuition for this, could be wrong.\"}\nIf the above paragraph was hard to get, I can explain with a more grounded example. \nI'm aware that the human brain and neural networks are not at all the same in the manner with which they function, and are designed but I couldn't think of an easier example, so bear with me. \n\nImagine a *guitar with a few broken strings*, after reading this text could your brain think up of an image showing the same? It might not be super clear, 4k quality or something, but you could in your head think of an image that had the most important features that a *guitar with a few broken strings* might have.\n\nI think that a `latent space` is just that neural network analog for that headspace we go into. Our brain was able to process and break-down the text and then also match it to a visual representation.\n\nSo we essentially need a model, that is capable of doing something similar to this in essence. CLIP is one such model that does this job.\n:::\n\nCLIP is made up of two models. A Text-encoder and an Image-encoder. \n```{mermaid}\nflowchart TD\n  T[\"Input text\"] --> TE([\"CLIP Text Encoder\"])\n  I[\"Input Image\"] --> IE([\"CLIP Image Encoder\"])\n  TE --> VT[\"Vector Representation of Text\"]\n  IE --> VI[\"Vector Representation of Image\"]\n  VT --> LS((\"Latent Space\"))\n  VI --> LS\n```\n\n\nBoth encoders need to be trained first with randomly selected weights. The 'CL' in CLIP stands for `contrastive loss` and that's what helps in training both the text and image encoders. Fancy name apart, training process is quite simple. \n\nLet's take three random text prompts:\n\n`Text 1`: *Muscular Hen's caricature*\n\n`Text 2`: *Broken Egg*\n\n`Text 3`: *Senior man with long hair and beard portrait*\n\nWe'll call the vector representation of each text prompt as `T1`, `T2`, `T3` respectively.\n\nWe also now have 3 images of the same, and we'll use `I1`, `I2`, `I3` to represent the vector representations of these images. All of these vector representations were generated by throwing them into the CLIP encoders (and they're random right now because we haven't trained CLIP yet).\n\nNow, we can make a grid with the Image vectors lined up along the columns and the Text vectors lined along the rows.\n\n![Training Grid](CLIP.png)\n\nEach cell of the grid contains the dot product of the two representation vectors. The dot product of vectors that actually describe an image with the right text will be the highest, i.e. of the diagonal cells. \n\nThe non-diagonal cells on the other hand, should have low values once the model is trained, because the embeddings are far apart from each other in the `latent-space`. The text representation vector is not correct for the image.\n\nNow as the final step, we sum up all the diagonals together and we also sum up all the non-diagonals separately. \n\n1. $Sum_d = \\text{Sum of Diagonals}$\n2. $Sum_nd = \\text{Sum of Non-Diagonals}$\n3. $Loss = Sum_d - Sum_nd$ \n\nThe loss function is known as `Contrastive Loss`, and it should be zero if all our generated embeddings are perfect matches.\n\nSo, to conclude this section. CLIP is a multi-modal model as our embeddings all share the same space and it helps us solve our second problem of not having a way to create embeddings for complex text.\n\n# Updated Model\n\n```{mermaid}\nflowchart LR\n  I[\"Noisy Latent Tensor\"] == \"(1)\" ==> M((\"U-Net\"))\n  G[\"CLIP Generated Embedding\"] == \"(1, 6)\" ==> M\n  M == \"(2)\" ==> O[\"Predicted Noise\"]\n  O == \"(3)\" ==> Z[\"Subtracted From\"]\n  Z == \"(4)\" ==> I\n  I == \"(5)\" ==> nI[\"Less Noisy Latent Tensor\"]\n  nI == \"(6)\" ==> M\n```\n\nNow our model can take any image as input with any arbritarily complex text describing what the image is about and our model would be able to use that as guidance to denoise input latents better.\n\nAnd what about generation? For image generation, our model could take as input any random bits of noise and convert that noise into something that matches the text embedding by using the feature vectors of the very same embedding.\n\nThis model could serve as the final one, but in practice stable diffusion has one extra implementation detail that we haven't discussed yet. It's called Time-Steps.\n\n\n# Time-Steps\n\nTo start off, time steps has nothing to do with time. It's just an overhang from the math of the first few papers written on stable defusion. \n\nIt's just a method of generating random noise for the inputs we pass in to our model. The noise used is varying and the `noise schedule` is some monotonically decreasing function.\n\n![Time-Steps v/s noise schedule](noise.png){width=70%}\n\n\nThe algorithm to pick noise is: \n\n1. Randomly choose a number b/w 1-100\n2. Look at noise schedule for that number.\n\n`t=1` has a lot of noise, 1000 has the least. So the time-step `t` is pretty much telling us how much noise to use.\n\nHow is this used in practice? \nWell, we generate noise using the 2 steps above for each image in our mini-batch and we add that generated noise to each image in the mini-batch respectively.\n\n:::{.callout-note}\nThese days, it's widely accepted that the addition of noise to input images using time-steps in stable-diffusion impacted the quality of the generated images negatively and it's not used in newer diffusion models.\n:::\n\n# Concluding QNA\n\nHow does whatever we did above tie in with the first equation we had?\n\n`Some Noisy Image` - $c*\\nabla_X P(X)$ \n\n1. What would the value of $c$ be and is it similar to learning rate?\n  : `Ans`. The value of $c$ depends on the diffusion sampler we use and yes $c$ is kind of like a learning rate.\n2. Why can't our model jump to the best image in one step?\n  : `Ans`. Because things that look weird and hideous like the image below don't appear in our training set, and our model doesn't know what to do with them.\n\n  ![hideous image generated by the model](ugly.png){width=70%}\n\n  Our model only knows how to deal with somewhat noisy images and that's it. It can only denoise whenever it sees some noise.\n\n  That's why we subtract just a bit of noise (hence the $c$), so that we are always left with some noisy latent.\n\n# References\n\n1. fastai practical deep learning for coders\n\n","srcMarkdownNoYaml":"\n:::{.callout-caution title=\"About this blog\" collapse=\"true\"}\nThis is my first ever blog and it's on a topic I find relatively hard, although I've tried my best to be accurate in whatever I write, It won't be surprising if this entire blog was riddled with inaccuracies and straight up incorrect stuff. I simply don't have that necessary but aquired oversight yet. So I'm asking the reader to help me out with any errors they might spot and I'll happily correct whatever it is that I presented wrong.\n:::\n# Introduction \nMost people reading this have probably heard of image generation at some point in time. If you're among those who haven't, then this journey will be even better as I go in some fair detail to try and explain what it is.\n\nIf at any point, the things I talk about seem hard, don't be discouraged as it's more of a shock if you find this easy to read. Nevertheless, buckle up because although we might not go all the way into the deep-end (I don't know enough stuff yet), I think we'll still get to dip our toes.\n\n![](buckleup.gif){width=40%}\n\\ \n\n# Cool AI generated images\nI'll just let the images speak.  \n\\\n\n::: {layout=\"[[1,1], [1]]\"}\n![cozy warm image of an indian male programmer sitting near a beautiful pond, scenic, matches white background, beautiful](img3.jpg){width=50%}\n\n![Dune arakis in the background. Paul Atreides giving speech. Crowd listening is charged, ominous foreboding theme.](img4.jpg){width=50%}\n\n![inspiring landscape poster showing humanity as a multiplanetary species, sprawling metropolis with large structures, awe-inspiring, 1920x1080 image, outer space](img5.jpg)\n:::\n\\\n\nAll of the above were generated with simple but detailed text prompts.\n\\ \n# Understanding the problem\n\n::: {.callout-caution}\nThis blog and deep learning in general have the tendency to contain lots of technical jargon. It might be something stupidly simple once you actually learn what it is, but for some reason the DL community likes cool names I guess. In case you're a bit rusty with some of the terms, I've defined most used in this blog.\n:::\n::: {.callout-note collapse='true' title='Jargon' }\n|Term | Meaning |\n|-----|------------|\n|parameters| The values in the model that change what task it can do, updated through model training|\n| architecture | The mathematical function that we pass input data and parameters to |\n|model | The combination of the architecture with a particular set of parameters|  \n|gradient | A Tensor that tells us how the vector field changes in any direction |\n| loss | A measure of how good the model is, chosen to drive training via stochastic gradient descent|\n|metric| A human readable way to measure the performance of a model |\n|CNN| Convolutional Neural Network; a type of NN that works well for computer vision tasks | \n| embeddings | A relatively-low dimension space into which we can translate high-dimensional vectors|\n| latent | A latent is a compressed, rough representation of a higher quality image. It consists of the most important features of an image|\n|latent space| A feature or embedding space where similar embeddings lie close to each other, and different farther.|\n|noise| Random variation of brightness or color information in images|\n|U-Net| Deep Learning architecture used for classifying each pixel in an image into a category or class|\n|VAE| Variational Auto Encoder|\n|CLIP| Contrastive Language-Image Pre-Training, a visual classification NN|\n|multimodal learning| A type of learning where the model is trained to understand and work with multiple forms of input data |\n:::\n\nIf you had to make a guess about how image generation works, what would that guess be? Think for a moment. If you're like me, then you probably thought that we try to get the model to spit out cool looking images, right? Well, not exactly. Bear with me for a moment.\n\\ \n\nImagine a magic function that takes in images of handwritten digits as inputs and spits out the probability that the input is a digit. \n\\ \n\nLet the probability be $P(X)$ for an input Image X.\n```{mermaid}\nflowchart LR\n  I1(X1) --> F((Magic Function))\n  I2(X2) --> F\n  I3(X3) --> F\n  F --> O1(\"P(X1)\")\n  F --> O2(\"P(X2)\")\n  F --> O3(\"P(X3)\")\n\n```\n\n\\\n\nWait. How do we use this function to generate new digits?\\\nWe do the following steps:\\\n\n1. Try making a pixel of X darker and then check the output probability\n2. Try making a pixel of X lighter and then check probability\n3. Do this for every pixel in X (If X is a 28x28 image, that's 784 times!)\n\nIn the above steps, we're calculating the change in probability of the images being handwritten wrt. to each pixel in the image (784 for a 28x28 image), mathematically it can be represented as follows: \n$$\\nabla_X P(X)$$\n\\\n\n::: {.callout-note}\n$\\nabla_X P(X)$ is itself a vector of size 784.\n:::\n\nNext step we do is to multiply $\\nabla_X P(X)$ with some constant.\n$$c*\\nabla_X P(X)$$\n\nNow we subtract the above term from the 784 pixel values of $X$ and in turn increase the output probability, and we do it a bunch of times.\\\n\n```{mermaid}\nflowchart LR\n  I(X) --> F((Magic Function))\n  F --> O(\"P(X)\")\n  O --> G[\"c * ∇ₓP(X)\"]\n  G --> S[\"-\"]\n  S --> I\n```\n\\\n\nHaving gone through all that, it would be an intelligent guess to say that now all we need is for someone to give us the magic function so we can start generating.\\\n\nBut there's some bad news, nobody is going to hand us any magical function that takes care of everything under the hood. We're going to have to train our own neural network on a lot of handwritten data to do this for us.\\\n\nSeems simple enough to do for any seasoned DL practitioner. Alas! There's a catch. Now I don't know the why or how, but smarter people than me figured out that it's pretty much practically impossible if not insanely hard to create a metric that tells us how much our image looks like a specific digit. \n\n:::{.callout-important}\nDon't forget that our end goal is making super pretty images like we saw at the start, not some basic digits.\n:::\nSo, they decided on an interesting but very logical approach.\\\n\n# An attempt at a basic image generation model\n\nEvery image we train on can be overlayed with some random amounts of noise, the result would be a noisier image of course but now we have some place to start with.\\\n`Noisy Image = Noise + Clear Image`\n\nWkt we can't predict how much an image looks like something, but turns out we can try and predict how noisy an image is, and then using basic arithmetic we can see that we'd just have to subtract that predicted noise from the noisy image to end up with a relatively clear Image. \\\n\nPassing in a starting pic and repeating this over and over would train our model to get good at predicting the noise in an image and getting rid of it. \\\n\nAnd once it has trained over enough inputs, it can generate new images for us because it now knows how to denoise inputs.\n\nSo we can use a model that works roughly in the fashion shown below:\n\n```{mermaid}\nflowchart LR\n  I[\"Input Image\"] == \"(1)\" ==> M((\"U-Net\"))\n  M == \"(2)\" ==> O[\"Predicted Noise\"]\n  O == \"(3)\" ==> Z[\"Subtracted from\"]\n  Z == \"(4)\" ==> I\n  I == \"(5)\" ==> nI[\"Less noisy image\"]\n  nI == \"(6)\" ==> M\n```\n\n\\\n\nAlthough the model above is decent, it can be optimised further using the concept of *guidance*. I'll explain.\\\n\nCurrently, at the start of the training process, we're leaving our model in the dark really with no clue about what digit it's supposed to identify since we're passing in somewhat noisy inputs.\\\n\nSay our model knew what it was supposed to look for, wouldn't it make logical sense then to pass in that thing? That's what guidance does. Along with the input (obviously), we also pass the digit our model is supposed to remove noise from.\\\n\nNow once the model is trained, *guidance* would help generate better new images, because it can denoise better! Duh. So our current model would actually end up looking more like: \n\n```{mermaid}\nflowchart LR\n  I[\"Input Image\"] == \"(1)\" ==> M((\"U-Net\"))\n  G[\"OHE Guidance Vector\"] == \"(1, 6)\" ==> M\n  M == \"(2)\" ==> O[\"Predicted Noise\"]\n  O == \"(3)\" ==> Z[\"Subtracted from\"]\n  Z == \"(4)\" ==> I\n  I == \"(5)\" ==> nI[\"Less noisy image\"]\n  nI == \"(6)\" ==> M\n```\n\n\n# Problems with our basic model\n\nIf we were living in the 90s, the model we built would certainly grab a lot of attention and maybe fame, but we're not. We have overlooked some very grave issues.\n\n1. We're not working with tiny $28x28$ pixel images of handwritten digits here, we're working with $512x512x3$ (High quality RGB) images.\n2. Each of our 9 handwritten digits can be one-hot encoded into a vector but beyond that, we can't one-hot encode infinite possible texts. \n\n:::{.callout-note }\nTry one hot encoding any phrase of your choice. It's hard.\n:::\n\nWell then, is our case hopeless here? Were the images I showed faked? No, for we have the `VAE autoencoder` and the `CLIP` multimodal encoders and decoders to the rescue. Let's understand what they are and get into how they solve both of our problems.\n\\\n\n## VAE: Variational Auto Encoder\n\n![Variational Auto Encoder](VAE.png)\n\n\\\nIn the context of our model, VAE is just a data compression and decompression algorithm with a fancy name.\\ \n\nVAE tries that what came in as input is the same as what comes out, it's architecture might look similar to U-Net but VAE does not have cross connections unlike the former and VAE is also an autoencoder.\\ \n\nThe special thing about autoencoders is that they can split in half and we can just use the encoder and decoder seperately.\n\nThe encoder serves as a great compression method and on the $512*512*3$ example it reduces the pixel count from $786,432$ to a mere $16,384$. A size reduction of $48$ times. \n\n:::{.callout-important}\nThe encoder peforms compression by doing stride 2 convolutions and doubling the channel size, this helps in increasing the complexity and expressive power of the model without increasing the spatial feature maps.\n\nSo, a stride 2 convolution reduces the spatial dimensions and memory usage and additional channels give the model more capacity to learn.\n:::\n\nAnd if we have a copy of the decoder, we can feed the encoded latent to it and end up with the high resolution image again. \n\nThis model serves a great compression algorithm because it's been trained on millions upon millions of input images, at the start of its training process, the VAE spits out random noise out of it's decoder but if we use the humble `Mean Squared Error` function on the encoder input and decoder output to train the VAE reduce the loss.\n\n\nHow it works is interesting though. VAE, is built up of two main components and each of them can work independently once the autoencoder has been trained.\\\n\nThe first part consists of the Encoder. This is where compression happens, we start with a high resolution image of $512*512*3$ and keep performing convolutions of stride 2 and doubling the channels till we end up with a relatively much lower dimension image. This image is called the `latent` and the multi-dimensional space it exists in is called the `latent space`.\n\n:::{.callout-note}\nA `latent` contains the most interesting and useful information of an image.\n\nA `channel` in a CNN refers to a specific component of the image data, in the case of a colour image, the channels typically represent different colors.\n\nA `feature` in CNN refers to specific characteristics or pattern in the input data that the network learns to recognise. These patterns can be simple or complex, early layers of a CNN features are basic patterns and deeper in the network, they're more abstract and complex.\n:::\n\n:::{.callout-note}\nA stride two convolution means that at each step, the convolution skips a column and a row. So for a $4*4$ grid, a stride 2 convolution would bring the size down\n:::\n\n```{mermaid}\nflowchart LR\n  A[\"High Res Image\"] --> M((\"VAE Encoder\"))\n  M --> O[\"Image Latent Tensor\"]\n```\n\nNow let's get back to what we need VAE for, the size problems our older model had. Since we can compress image sizes by godly amounts, there's no doubt, that we'll train the U-Net model with these encoded images (latents).\n\nSo, if our U-Net needs to be trained on 10 million images, we'll pass each one of them through `VAE's encoder` first, and then we feed these latents into the U-Net 100s to 1000s of times.\n\n:::{.callout-caution}\nDon't forget that U-Net denoises input images through repetition.\n:::\n\nNow our model looks like this:\n```{mermaid}\nflowchart LR\n  I[\"Noisy Latent Tensor\"] == \"(1)\" ==> M((\"U-Net\"))\n  G[\"OHE Guidance Vector\"] == \"(1, 6)\" ==> M\n  M == \"(2)\" ==> O[\"Predicted Noise\"]\n  O == \"(3)\" ==> Z[\"Subtracted From\"]\n  Z == \"(4)\" ==> I\n  I == \"(5)\" ==> nI[\"Less Noisy Latent Tensor\"]\n  nI == \"(6)\" ==> M\n```\n\nWouldn't this new latent based model spit out latents too? Yes, it will but we don't forget that we also have the other half of our autoencoder. The `VAE decoder` will be able to take in the generated latent as input and then output a high resolution image. It'd be like there wasn't any compression-decompression to begin with. \n\n```{mermaid}\nflowchart LR\n  A[\"U-Net Output Latent\"] --> M((\"VAE Decoder\"))\n  M --> O[\"High Res Version of Generated Image\"]\n```\n\nTechnically we don't need to use an autoencoder, but it greatly saves on computation necessary and the time it takes to generate an image as well as the modern training itself.\n\n:::{.callout-note}\n`VAE encoder`: Used during model training.\n\n`VAE decoder`: Used during model inference.\n:::\n\n## CLIP\n\nIgnore the weird name for now and focus on the second problem we had. \nWhich was, finding a way to create embeddings for any possible text and not just the digits b/w 0 to 9 so we could guide the model.\n\nWhat if we had a model that spat out a vector representation of every complex sentence, such that we could pass it with our `latent tensor` as `guidance`. And what if, that model created textual embeddings in such a way, that they ended up being close to the `latent tensor`'s embedding in the `latent space`.\n\n:::{.callout-warning collapse=\"true\" title=\"My personal intuition for this, could be wrong.\"}\nIf the above paragraph was hard to get, I can explain with a more grounded example. \nI'm aware that the human brain and neural networks are not at all the same in the manner with which they function, and are designed but I couldn't think of an easier example, so bear with me. \n\nImagine a *guitar with a few broken strings*, after reading this text could your brain think up of an image showing the same? It might not be super clear, 4k quality or something, but you could in your head think of an image that had the most important features that a *guitar with a few broken strings* might have.\n\nI think that a `latent space` is just that neural network analog for that headspace we go into. Our brain was able to process and break-down the text and then also match it to a visual representation.\n\nSo we essentially need a model, that is capable of doing something similar to this in essence. CLIP is one such model that does this job.\n:::\n\nCLIP is made up of two models. A Text-encoder and an Image-encoder. \n```{mermaid}\nflowchart TD\n  T[\"Input text\"] --> TE([\"CLIP Text Encoder\"])\n  I[\"Input Image\"] --> IE([\"CLIP Image Encoder\"])\n  TE --> VT[\"Vector Representation of Text\"]\n  IE --> VI[\"Vector Representation of Image\"]\n  VT --> LS((\"Latent Space\"))\n  VI --> LS\n```\n\n\nBoth encoders need to be trained first with randomly selected weights. The 'CL' in CLIP stands for `contrastive loss` and that's what helps in training both the text and image encoders. Fancy name apart, training process is quite simple. \n\nLet's take three random text prompts:\n\n`Text 1`: *Muscular Hen's caricature*\n\n`Text 2`: *Broken Egg*\n\n`Text 3`: *Senior man with long hair and beard portrait*\n\nWe'll call the vector representation of each text prompt as `T1`, `T2`, `T3` respectively.\n\nWe also now have 3 images of the same, and we'll use `I1`, `I2`, `I3` to represent the vector representations of these images. All of these vector representations were generated by throwing them into the CLIP encoders (and they're random right now because we haven't trained CLIP yet).\n\nNow, we can make a grid with the Image vectors lined up along the columns and the Text vectors lined along the rows.\n\n![Training Grid](CLIP.png)\n\nEach cell of the grid contains the dot product of the two representation vectors. The dot product of vectors that actually describe an image with the right text will be the highest, i.e. of the diagonal cells. \n\nThe non-diagonal cells on the other hand, should have low values once the model is trained, because the embeddings are far apart from each other in the `latent-space`. The text representation vector is not correct for the image.\n\nNow as the final step, we sum up all the diagonals together and we also sum up all the non-diagonals separately. \n\n1. $Sum_d = \\text{Sum of Diagonals}$\n2. $Sum_nd = \\text{Sum of Non-Diagonals}$\n3. $Loss = Sum_d - Sum_nd$ \n\nThe loss function is known as `Contrastive Loss`, and it should be zero if all our generated embeddings are perfect matches.\n\nSo, to conclude this section. CLIP is a multi-modal model as our embeddings all share the same space and it helps us solve our second problem of not having a way to create embeddings for complex text.\n\n# Updated Model\n\n```{mermaid}\nflowchart LR\n  I[\"Noisy Latent Tensor\"] == \"(1)\" ==> M((\"U-Net\"))\n  G[\"CLIP Generated Embedding\"] == \"(1, 6)\" ==> M\n  M == \"(2)\" ==> O[\"Predicted Noise\"]\n  O == \"(3)\" ==> Z[\"Subtracted From\"]\n  Z == \"(4)\" ==> I\n  I == \"(5)\" ==> nI[\"Less Noisy Latent Tensor\"]\n  nI == \"(6)\" ==> M\n```\n\nNow our model can take any image as input with any arbritarily complex text describing what the image is about and our model would be able to use that as guidance to denoise input latents better.\n\nAnd what about generation? For image generation, our model could take as input any random bits of noise and convert that noise into something that matches the text embedding by using the feature vectors of the very same embedding.\n\nThis model could serve as the final one, but in practice stable diffusion has one extra implementation detail that we haven't discussed yet. It's called Time-Steps.\n\n\n# Time-Steps\n\nTo start off, time steps has nothing to do with time. It's just an overhang from the math of the first few papers written on stable defusion. \n\nIt's just a method of generating random noise for the inputs we pass in to our model. The noise used is varying and the `noise schedule` is some monotonically decreasing function.\n\n![Time-Steps v/s noise schedule](noise.png){width=70%}\n\n\nThe algorithm to pick noise is: \n\n1. Randomly choose a number b/w 1-100\n2. Look at noise schedule for that number.\n\n`t=1` has a lot of noise, 1000 has the least. So the time-step `t` is pretty much telling us how much noise to use.\n\nHow is this used in practice? \nWell, we generate noise using the 2 steps above for each image in our mini-batch and we add that generated noise to each image in the mini-batch respectively.\n\n:::{.callout-note}\nThese days, it's widely accepted that the addition of noise to input images using time-steps in stable-diffusion impacted the quality of the generated images negatively and it's not used in newer diffusion models.\n:::\n\n# Concluding QNA\n\nHow does whatever we did above tie in with the first equation we had?\n\n`Some Noisy Image` - $c*\\nabla_X P(X)$ \n\n1. What would the value of $c$ be and is it similar to learning rate?\n  : `Ans`. The value of $c$ depends on the diffusion sampler we use and yes $c$ is kind of like a learning rate.\n2. Why can't our model jump to the best image in one step?\n  : `Ans`. Because things that look weird and hideous like the image below don't appear in our training set, and our model doesn't know what to do with them.\n\n  ![hideous image generated by the model](ugly.png){width=70%}\n\n  Our model only knows how to deal with somewhat noisy images and that's it. It can only denoise whenever it sees some noise.\n\n  That's why we subtract just a bit of noise (hence the $c$), so that we are always left with some noisy latent.\n\n# References\n\n1. fastai practical deep learning for coders\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"number-sections":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","theme":"slate","title-block-banner":true,"title":"Noisy to Nice","description":"An amateur's guide to stable diffusion.","author":"Harsh Sharma","date":"10/31/2023","image":"logo.png","toc-expand":2,"toc-title":"Contents","toc-location":"left","number-depth":3,"categories":["Notes","Fastai Part2"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}